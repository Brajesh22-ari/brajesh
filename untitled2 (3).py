# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oi2a0HgXe3nrZxAeo8nLm_KWu_rmSJ3A
"""

1. What are data structures, and why are they important?
ANS= A data structure is a special way of organizing and storing data in a computer so that it can be used efficiently. Think of it like a container or system that helps manage information.

Why Are Data Structures Important?
‚úÖ Efficient Data Management
They allow storing and retrieving data quickly (e.g., searching, sorting, inserting, deleting).

‚úÖ Better Performance
Choosing the right data structure can significantly improve the speed and performance of a program.

‚úÖ Organized Code
Help in writing clean, maintainable, and reusable code.

‚úÖ Solving Complex Problems
Many algorithms rely on specific data structures to work correctly (e.g., Dijkstra‚Äôs algorithm uses graphs).

‚úÖ Essential in Interviews
Almost every technical job interview includes questions on data structures and algorithms.



2. Explain the difference between mutable and immutable data types with examples.


ANS= üîÅ Difference Between Mutable and Immutable Data Types in Python:
Property	Mutable	Immutable
Definition	Can be changed after creation	Cannot be changed after creation
Examples	list, dict, set, bytearray	int, float, str, tuple, bool, bytes
Memory Address	May stay the same when modified	New object is created when changed

‚úÖ Mutable Data Types:
These can be modified in place without changing their identity (memory address).

Example: List (Mutable)

python

my_list = [1, 2, 3]
print(id(my_list))   # Memory address before
my_list.append(4)
print(my_list)       # Output: [1, 2, 3, 4]
print(id(my_list))   # Same memory address
my_str = "hello"
print(id(my_str))     # Memory address before
my_str = my_str + " world"
print(my_str)         # Output: "hello world"
print(id(my_str))     # New memory address


3.What are the main differences between lists and tuples in Python?
ANS= Main Differences Between Lists and Tuples in Python 3
Feature	List	Tuple
Mutability	‚úÖ Mutable (can be changed)	‚ùå Immutable (cannot be changed)
Syntax	[1, 2, 3]	(1, 2, 3)
Performance	Slower (more overhead)	Faster (less overhead)
Use Case	When data needs to change	When data must stay constant
Methods Available	More (like .append(), .pop())	Fewer (mostly read-only methods)
Can be Dictionary Key?	‚ùå No	‚úÖ Yes (if all elements are hashable)

4.Describe how dictionaries store data.
ANS=Dictionaries, also known as maps or associative arrays, store data in key-value pairs, allowing for efficient data retrieval based on unique keys. Keys are used to access their corresponding values, similar to indices in an array, but offering the flexibility to use any hashable object as a key.

5.Why might you use a set instead of a list in Python?
ANS.Sets and lists are both used to store collections of items in Python, but they have different characteristics that make them suitable for different tasks. Here are some reasons why you might choose a set over a list:
Uniqueness
Sets only store unique elements. If you try to add a duplicate element to a set, it will be ignored. Lists, on the other hand, can contain duplicate elements.
Unordered
Sets do not maintain the order of elements. The order in which elements are added to a set is not guaranteed to be the order in which they are stored or retrieved. Lists, on the other hand, maintain the order of elements.
Membership Testing
Sets are optimized for membership testing. Checking if an element exists in a set is typically faster than checking if an element exists in a list, especially for large collections.

"""6.What is a string in Python, and how is it different from a list3


ANS.A string is a sequence of characters enclosed in single ('...') or double ("...") quotes‚Äîe.g., "hello"
ranyel.medium.com
.

Python has no separate character type; a single letter like 'a' is still a string of length 1 .

Strings are immutable, meaning once created, you can‚Äôt change individual characters‚Äîe.g., doing s[0] = 'x' raises an error. To modify, you must create a new string
geeksforgeeks.org
+1
cs.swarthmore.edu
+1
.

üõ†Ô∏è What is a list in Python?
A list is a general-purpose sequence container defined with square brackets‚Äîe.g., [1, "a", 3.14]
geeksforgeeks.org
.

Lists can hold mixed data types, not just characters
en.wikipedia.org
+5
discuss.codecademy.com
+5
en.wikipedia.org
+5
.

They are mutable, which means you can change elements in place (e.g., my_list[2] = "new" works fine)
cs.swarthmore.edu
+1
developers.google.com
+1

7.How do tuples ensure data integrity in Python?
ANS..| Feature                                    | Description        

| **1. Immutability**                        | Once a tuple is created, you **cannot add, remove, or change** any of its elements. This prevents accidental or unauthorized changes to the data.               |
| **2. Hashable (if elements are hashable)** | Tuples can be used as keys in dictionaries and elements of sets (unlike lists), which require the key to never change. This enforces stability in mapping data. |
| **3. Safe for fixed data structures**      | Ideal for representing data that should not be modified‚Äîfor example, coordinates `(x, y)`, RGB color values, or database records.                               |
| **4. Predictable behavior**                | Tuples maintain **order and structure** but not mutability‚Äîso code using them is easier to reason about and less prone to side effects.                         |
person = ("Brajesh", 30, "India")
# person[1] = 31  ‚ùå TypeError: 'tuple' object does not support item assignment
| Feature             | Tuple                       | List                    |
| ------------------- | --------------------------- | ----------------------- |
| Mutability          | ‚ùå No                        | ‚úÖ Yes                   |
| Data Integrity      | ‚úÖ Enforced by design        | ‚ùå Can be changed easily |
| Use in `dict`/`set` | ‚úÖ If elements are immutable | ‚ùå Lists are unhashable  |

8.What is a hash table, and how does it relate to dictionaries in Python?
ANS.A hash table is a data structure that stores key‚Äìvalue pairs and allows fast data access based on keys. It's the underlying structure used by dictionaries in Python.

üì¶ What is a hash table?
A hash table works like this:

Hashing the key: A special function (called a hash function) converts the key (like "name" or 42) into a numeric index.

Indexing into an array: This index points to a location in an internal array (called a bucket) where the value is stored.

Fast lookup: Instead of searching through all the data, Python jumps directly to the correct index using the hash, making operations very fast‚Äîon average O(1) time.

üß† How it relates to Python dictionaries
Python's dict is a high-level abstraction of a hash table, offering:

Fast lookups (e.g. my_dict["name"])

Efficient insertions and deletions

Unique keys: because hash tables do not allow duplicate keys

Hashing rules: keys must be hashable (i.e., immutable like strings, numbers, or tuples)

my_dict = {"name": "Brajesh", "age": 30}
"name" is hashed ‚Üí say to index 4 ‚Üí Python stores "Brajesh" there.

"age" is hashed ‚Üí say to index 9 ‚Üí Python stores 30 there.

When you do my_dict["name"], Python doesn't search through the dictionary. It just rehashes "name" and jumps to index 4.

üõ°Ô∏è What if two keys hash to the same index?
This is called a collision, and Python handles it using techniques like:

Open addressing: looks for the next available bucket

Probing strategies: to resolve where to place data without losing it

üîç Summary
Feature	Hash Table	Python Dictionary (dict)
Structure	Array + hash function	Built on hash table
Key access time	O(1) average	O(1) average
Handles collisions	Yes	Yes (internally managed)
Requires unique keys	Yes	Yes
Requires hashable keys	Yes	Yes (__hash__() method required)

‚úÖ Conclusion
A dictionary in Python is a hash table in disguise‚Äîoptimized and powerful. It lets you store and retrieve values by key quickly, thanks to hashing.

Let me know if you want to see a visual or step-by-step simulation of how a hash table works!

9. Can lists contain different data types in Python?
ANS.Yes, lists in Python can contain different data types.

This is one of the key features of Python lists‚Äîthey are heterogeneous containers, meaning you can store items of different types in the same list.

‚úÖ Example:
python
Copy
Edit
mixed_list = [10, "hello", 3.14, True, [1, 2], {"key": "value"}]
print(mixed_list)
[10, 'hello', 3.14, True, [1, 2], {'key': 'value'}]
Here the list contains:

An integer (10)

A string ("hello")

A float (3.14)

A boolean (True)

Another list ([1, 2])

A dictionary ({"key": "value"})

10. Explain why strings are immutable in Python.
AnS..:
üîí Why Are Strings Immutable in Python?
Strings in Python are immutable, meaning once a string is created, it cannot be changed. Any operation that seems to modify a string actually creates a new string.

‚úÖ Reasons Why Strings Are Immutable:
1. Performance & Memory Efficiency
Strings are used frequently in Python (e.g., variable names, dictionary keys, text processing).

Immutability allows string interning, where Python reuses identical string objects to save memory and speed up comparisons.

a = "hello"
b = "hello"
print(a is b)  # True ‚Äî both point to the same object
. Security and Reliability
Since strings often represent sensitive data (e.g., file paths, database queries), making them immutable helps prevent accidental or malicious modification.

3. Hashability
Immutability makes strings hashable, meaning they can be used as:

Keys in dictionaries: {"name": "Brajesh"}

Elements in sets: {"apple", "banana"}

If strings were mutable, their hash values could change, which would break dictionary

11. What advantages do dictionaries offer over lists for certain tasks?
ANS.Dictionaries in Python offer significant advantages over lists for certain tasks‚Äîespecially when you need to work with key-value pairs and require fast lookups. Here‚Äôs a clear comparison to help you understand when and why to use dictionaries:

‚úÖ Key Advantages of Dictionaries over Lists:
Feature	Dictionary (dict)	List (list)
üîç Fast lookup by key	O(1) average time using hash table	O(n) time (must scan through the list)
üóÇÔ∏è Key-value pairing	Stores data with meaningful labels (keys)	Stores items in a numbered sequence
üöÄ Efficient updates	Quickly update values by key: data["age"] = 30	Must search for item or use index
‚ùå Avoids duplicates by key	Keys must be unique	Lists allow duplicate values
‚úÖ Flexible data access	Access by name: person["name"]	Access by index: person[0]
 Ideal for structured data	Great for objects, records, configs, JSON data	Better for ordered collections or sequences
 üß† Example Use Case
üî∏ Using a List:
python
person = ["Brajesh", 30, "India"]
# Hard to know what each index represents
üîπ Using a Dictionary:
python
Copy
Edit
person = {"name": "Brajesh", "age": 30, "country": "India"}
print(person["name"])  # Easy and clear access

12. Describe a scenario where using a tuple would be preferable over a list.
ANS.‚úÖ Scenario: Using a Tuple Instead of a List
# A tuple is preferable over a list when you want to store a fixed collection of items that should not be changed‚Äîthis helps ensure data integrity and allows safe usage in data structures like dictionaries or sets.

üìå Real-World Scenario: Representing Coordinates
Suppose you're working on a mapping or graphics program, and you need to represent points on a grid or canvas.

python

point = (100, 200)
Why use a tuple?
Reason	Explanation
üîí Immutability	Coordinates shouldn't change accidentally‚Äîtuples protect them from updates
‚ö° Hashable	Tuples can be used as keys in dictionaries or elements in sets
üß† Clear intent	A tuple says: "this is a fixed-size, read-only group of values"
üß© Performance	Tuples are slightly more memory-efficient and faster than lists

13.How do sets handle duplicate values in Python?
ANS.In Python, sets are designed to store only unique elements. When you attempt to add a duplicate value to a set, it does not raise an error, but it also does not add the duplicate. The set simply ignores the duplicate value, ensuring that it maintains its property of containing only unique elements.
For example:
Python

my_set = {1, 2, 2, 3, 4, 4, 5}
print(my_set)
Output:
Code

{1, 2, 3, 4, 5}
As you can see, the duplicate values 2 and 4 were ignored, and the set contains only one instance of each unique element.

14.How does the ‚Äúin‚Äù keyword work differently for lists and dictionaries?

ANS.The in keyword in Python is used to check for membership, but it works differently for lists and dictionaries based on what they store.
fruits = ["apple", "banana", "mango"]
print("banana" in fruits)  # ‚úÖ True
print("grape" in fruits)   # ‚ùå False
‚úÖ in checks if a value exists in the list.

It searches through the list sequentially (O(n)).

person = {"name": "Brajesh", "age": 30}
print("name" in person)    # ‚úÖ True (key exists)
print("Brajesh" in person) # ‚ùå False (value, not key)
‚úÖ in checks if a key exists in the dictionary.

It uses hashing ‚Üí very fast (O(1) average).

15. Can you modify the elements of a tuple? Explain why or why not?
ANS. No, you cannot modify the elements of a tuple in Python. Tuples are immutable, meaning once a tuple is created, its elements cannot be changed, added, or removed.
my_tuple = (10, 20, 30)
my_tuple[1] = 99  # ‚ùå Raises: TypeError: 'tuple' object does not support item assignment
my_tuple = (1, [2, 3], 4)
my_tuple[1].append(5)
print(my_tuple)  # Output: (1, [2, 3, 5], 4)




16. What is a nested dictionary, and give an example of its use case?
ANS.  A nested dictionary in Python is a dictionary where the values are themselves dictionaries. This allows you to create hierarchical data structures, grouping related data within a single dictionary.
Use Case Example:
Consider representing student data in a Python dictionary. You could use a nested dictionary to organize information about students, including their name, course enrollment, and grades.
student_data = {
  'Alice': {
    'courses': ['Math', 'Physics', 'English'],
    'grades': {'Math': 'A', 'Physics': 'B', 'English': 'C'}
  },
  'Bob': {
    'courses': ['Math', 'Chemistry', 'History'],
    'grades': {'Math': 'B', 'Chemistry': 'A', 'History': 'C'}
  }
}
"""

17. Describe the time complexity of accessing elements in a dictionary.
ANS. ‚è±Ô∏è Time Complexity of Accessing Elements in a Dictionary
In Python, accessing an element in a dictionary by key is very fast‚Äîthanks to the underlying hash table implementation.

‚úÖ Average Case Time Complexity
scss

O(1) ‚Äî Constant Time
When you do something like my_dict["name"], Python uses the key's hash value to directly jump to the right memory location.

This makes dictionary lookups very efficient, even for large datasets.

‚ö†Ô∏è Worst Case Time Complexity
scss

O(n) ‚Äî Linear Time
This happens rarely, only when:

Many keys hash to the same index (a hash collision)

Python must search through multiple items in one bucket

Python handles this with collision resolution techniques, like open addressing, to keep performance close to O(1) in most cases.

üìå Example
python

data = {"id": 101, "name": "Brajesh", "role": "Developer"}
print(data["name"])  # O(1) time
üß† Summary Table
Operation	Average Case	Worst Case
Access (dict[key])	O(1)	O(n)
Insert/Update	O(1)	O(n)
Delete (del dict[key])	O(1)	O(n)

‚úÖ Key Takeaway:
Python dictionaries are highly optimized for fast access, making them one of the most powerful built-in data structures for lookups, caching, and mapping relationships.

Let me know if you want to see how this compares with lists or sets!





18. In what situations are lists preferred over dictionaries?
ANS.Lists are often preferred over dictionaries when order matters, or when dealing with data that may change in the future. Lists are also useful for ordered operations like sorting, and when dealing with data that may need to be iterated upon.
Here's a more detailed breakdown of when lists are a better choice:
Maintaining Order:
Lists are ideal when the sequence of elements is crucial. For example, if you're tracking user actions in a specific order, a list would be appropriate.
Iterating and Processing:
Lists are easily iterable, making them great for looping through data, performing calculations, or transforming data.
Sorting and Shuffling:
Lists allow for easy sorting and shuffling of elements, making them suitable for tasks like generating random lists or arranging data in a specific way.
Storing a Collection of Related Objects:
Lists can hold heterogeneous collections of related objects, allowing for flexibility in data storage.
Dynamically Changing Data:

"""19.Why are dictionaries considered unordered, and how does that affect data retrieval?
ANS.Historically, dictionaries in Python were considered unordered because they didn‚Äôt preserve the insertion order of items before Python 3.7. The keys and values were stored based on hashes, not positions, so the order in which you added items wasn't guaranteed to be maintained.

üïì Python 3.7 and Later:
Since Python 3.7 (and officially guaranteed in 3.8+), dictionaries do preserve insertion order.

python
data = {"a": 1, "b": 2, "c": 3}
print(data)  # Output: {'a': 1, 'b': 2, 'c': 3}
Example,info = {"name": "Brajesh", "age": 25, "city": "Dehradun"}

# You can do this:
print(info["city"])  # Output: Dehradun

# But NOT this:
# print(info[0])  # ‚ùå KeyError or unexpected result

20. Explain the difference between a list and a dictionary in terms of data retrieval.
ANS. Difference Between List and Dictionary in Data Retrieval
Lists and dictionaries are both built-in data structures in Python, but they differ in how you retrieve data from them:

üìã 1. List: Retrieval by Index (Position)
Lists store items in a sequential order

You retrieve elements using numeric indices (starting from 0)
fruits = ["apple", "banana", "cherry"]
print(fruits[1])  # Output: banana
2. Dictionary: Retrieval by Key
Dictionaries store key-value pairs

You retrieve data using a key, not an index

python

person = {"name": "Brajesh", "age": 25}
print(person["name"])  # Output: Brajesh
"""

{PRACTICAL QUESTION}

1.Write a code to create a string with your name and print it.
name = "Brajesh"
print(name)

2.Write a code to find the length of the string "Hello World"

 the Python code to find the length of the string `"Hello World"`:

`python
text = "Hello World"
length = len(text)
print(length)


3.Write a code to slice the first 3 characters from the string "Python Programming"
text = "Python Programming"
first_three = text[:3]
print(first_three)

4. Write a code to convert the string "hello" to uppercase.
Ans.text = "hello"
uppercase_text = text.upper()
print(uppercase_text)

5.Write a code to replace the word "apple" with "orange" in the string "I like apple"

Ans.text = "I like apple"
new_text = text.replace("apple", "orange")
print(new_text)

6.Write a code to create a list with numbers 1 to 5 and print it.
Ans.numbers = [1, 2, 3, 4, 5]
print(numbers)

7.Write a code to append the number 10 to the list [1, 2, 3, 4].
Ans.numbers = [1, 2, 3, 4]
numbers.append(10)
print(numbers)

8.Write a code to remove the number 3 from the list [1, 2, 3, 4, 5].
Ans.numbers = [1, 2, 3, 4, 5]
numbers.remove(3)
print(numbers)

9.Write a code to access the second element in the list ['a', 'b', 'c', 'd'].
ANS.letters = ['a', 'b', 'c', 'd']
second_element = letters[1]
print(second_element)

10.Write a code to reverse the list [10, 20, 30, 40, 50].
Ans. Here's the Python code to reverse the list [10, 20, 30, 40, 50]:

python

numbers = [10, 20, 30, 40, 50]
numbers.reverse()
print(numbers)
üîÑ Alternative using slicing:
python

numbers = [10, 20, 30, 40, 50]
reversed_list = numbers[::-1]
print(reversed_list)



11.Write a code to create a tuple with the elements 100, 200, 300 and print it.
ANS.my_tuple = (100, 200, 300)
print(my_tuple)

12.Write a code to access the second-to-last element of the tuple ('red', 'green', 'blue', 'yellow').
ANS.colors = ('red', 'green', 'blue', 'yellow')
second_to_last = colors[-2]
print(second_to_last)

13.Write a code to find the minimum number in the tuple (10, 20, 5, 15)
Ans.numbers = (10, 20, 5, 15)
minimum = min(numbers)
print(minimum)


 14.Write a code to find the index of the element "cat" in the tuple ('dog', 'cat', 'rabbit').
 ANS.animals = ('dog', 'cat', 'rabbit')
index_of_cat = animals.index("cat")
print(index_of_cat)

 15. Write a code to create a tuple containing three different fruits and check if "kiwi" is in it.

ANS.# 1. Create a tuple containing three fruits
:contentReference[oaicite:4]{index=4}

# 2. Check if "kiwi" is in the tuple
:contentReference[oaicite:5]{index=5}
    :contentReference[oaicite:6]{index=6}
else:
    :contentReference[oaicite:7]{index=7}

16.Write a code to create a set with the elements 'a', 'b', 'c' and print it.
ANS.my_set = set(['a', 'b', 'c'])
print(my_set)

17 Write a code to clear all elements from the set {1, 2, 3, 4, 5}.
ANS.# Original set
:contentReference[oaicite:1]{index=1}

# Clear all elements (in-place)
my_set.clear()

# Print the now-empty set
:contentReference[oaicite:2]{index=2}

18.Write a code to remove the element 4 from the set {1, 2, 3, 4}.
Ans.# Original set
my_set = {1, 2, 3, 4}

# Remove the element 4
my_set.remove(4)

# Print the updated set
print(my_set)  # Output: {1, 2, 3}

19.. Write a code to find the union of two sets {1, 2, 3} and {3, 4, 5}.
ANS.# Define the two sets
set1 = {1, 2, 3}
set2 = {3, 4, 5}

# Find the union using union() method
union_set = set1.union(set2)

# Print the result
print(union_set)  # Output: {1, 2, 3, 4, 5}

union_set = set1 | set2
print(union_set)  # Output: {1, 2, 3, 4, 5}

20.Write a code to find the intersection of two sets {1, 2, 3} and {2, 3, 4}.
ANS.# Define the two sets
set1 = {1, 2, 3}
set2 = {2, 3, 4}

# Find the intersection using intersection() method
intersection_set = set1.intersection(set2)

# Print the result
print(intersection_set)  # Output: {2, 3}

intersection_set = set1 & set2
print(intersection_set)  # Output: {2, 3}

21.Write a code to create a dictionary with the keys "name", "age", and "city", and print it.
ANS.# Create the dictionary
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

# Print the dictionary
print(person)

  Output:
bash

{'name': 'Alice', 'age': 30, 'city': 'New York'}

22.Write a code to add a new key-value pair "country": "USA" to the dictionary {'name': 'John', 'age': 25}.
ANS.# Original dictionary
person = {'name': 'John', 'age': 25}

# Add new key-value pair
person['country'] = 'USA'

# Print the updated dictionary
print(person)


Output:
bash

{'name': 'John', 'age': 25, 'country': 'USA'}

23.Write a code to access the value associated with the key "name" in the dictionary {'name': 'Alice', 'age': 30}.
Ans.# Define the dictionary
person = {'name': 'Alice', 'age': 30}

# Access the value associated with the key "name"
name_value = person['name']

# Print the value
print(name_value)

24. Write a code to remove the key "age" from the dictionary {'name': 'Bob', 'age': 22, 'city': 'New York'}
ANS.# Original dictionary
person = {'name': 'Bob', 'age': 22, 'city': 'New York'}

# Remove the key "age"
del person['age']

# Print the updated dictionary
print(person)

25.Write a code to check if the key "city" exists in the dictionary {'name': 'Alice', 'city': 'Paris'}.
ANS.# Define the dictionary
person = {'name': 'Alice', 'city': 'Paris'}

# Check if "city" is a key in the dictionary
if 'city' in person:
    print("Key 'city' exists in the dictionary.")
else:
    print("Key 'city' does not exist in the dictionary.")

26.Write a code to create a list, a tuple, and a dictionary, and print them all.
ANS.# Create a list
my_list = [1, 2, 3, 4, 5]

# Create a tuple
my_tuple = ('apple', 'banana', 'cherry')

# Create a dictionary
my_dict = {'name': 'Alice', 'age': 30, 'city': 'Paris'}

# Print all of them
print("List:", my_list)
print("Tuple:", my_tuple)
print("Dictionary:", my_dict)

27.Write a code to create a list of 5 random numbers between 1 and 100, sort it in ascending order, and print the
result.(replaced)
ANS.import random

# Create a list of 5 random numbers between 1 and 100
random_numbers = [random.randint(1, 100) for _ in range(5)]

# Sort the list in ascending order
random_numbers.sort()

# Print the result
print("Sorted list:", random_numbers)

28.Write a code to create a list with strings and print the element at the third index.
ANS.# Create a list with strings
string_list = ["apple", "banana", "cherry", "date", "elderberry"]

# Print the element at the third index (index starts from 0)
print("Element at third index:", string_list[3])

29.Write a code to combine two dictionaries into one and print the result.

ans.# Define two dictionaries
dict1 = {"name": "Alice", "age": 25}
dict2 = {"city": "Paris", "country": "France"}

# Combine the dictionaries
combined_dict = {**dict1, **dict2}

# Print the result
print("Combined dictionary:", combined_dict)
Combined dictionary: {'name': 'Alice', 'age': 25, 'city': 'Paris', 'country': 'France'}

30.Write a code to convert a list of strings into a set.
ANS.# Create a list of strings
string_list = ["apple", "banana", "cherry", "apple", "banana"]

# Convert the list into a set
string_set = set(string_list)

# Print the result
print("Set:", string_set)